# F3 数字逻辑电路基础（下）

## 整数的机器级表示

### 无符号数和有符号数

无符号二进制整数（无符号数）：每一个二进制位都代表真值的大小，最小为0，最大为$2^{n}-1$

有符号二进制整数（有符号数）：通过1位来编码整数的符号位，剩下用于编码整数的绝对值

### 原码(sign-and-magnitude)

这是人类最喜欢的表示法，给数字贴个符号标签。

- **长相：** `[符号位] [绝对值]`
  - `+7` = `0000 0111`
  - `-7` = `1000 0111` (只是把最高位改成 1)
- **RCA 闯关测试：**
  - ✅ **正 + 正：** `7 + 34`。结果正确。
  - ❌ **负 + 负：** `-7 + (-34)`。RCA 算出来是 `-41` 吗？不，它把符号位也当数字加了，结果错乱。
  - ❌ **正 + 负：** `7 + (-7)`。RCA 算出来是 `-14` (`1000 1110`)，而不是 `0`。

#### ☠️ 致命缺陷

想象一个时钟，指针顺时针转应该是 $+1$。

1. **断层陷阱：** 在 `0000` (+0) 和 `1000` (-0) 之间有个大坑。
2. **逆行灾难：**
   - 我们希望：`(-4) + 1 = (-3)` （数值变大）。
   - 原码实际：`(-4)` 是 `1100`，加 1 变成 `1101` (`-5`)。**数值反而变小了！**
   - *结论：原码的负数半圆，是逆着长的。*

为了计算原码加法, 电路上还需要设计一个**减法器**, 然后根据两数符号和绝对值的情况, 选择出正确的处理结果

> **IC 工程师评价：** 垃圾设计。如果用原码，我得先判断符号，再比较绝对值大小，再决定是用加法器还是减法器。**硬件成本太高，Pass！**

### 反码(one's complement)

为了解决原码“负数逆行”的问题，工程师想到了按位取反。

- **长相：** 正数不变，负数全部取反。
  - `+7` = `0000 0111`
  - `-7` = `1111 1000`
- **RCA 闯关测试：**
  - ✅ **正 + 正：** 通过。
  - ✅ **方向修正：** 现在 `(-4) + 1` 确实等于 `(-3)` 了。负数部分也是顺时针增长的。
  - ❌ **跨越 0 点失败：**
    - `7 + (-7)`。RCA 算出来是 `1111 1111`。这是啥？这是 **-0**。
    - 更离谱的是：如果你算 `7 + (-0)`，结果会变成 `6`。**凭空少了一个 1！**

#### ☠️ 致命缺陷

- **-0 的幽灵：** 这种编码里有两个 0：`0000 0000` (+0) 和 `1111 1111` (-0)。
- **数学意义不连续：** 在时钟上，从 `-0` 到 `+0` 还是有个断层。每次跨越这个断层，计算结果就会**少 1**。

> **IC 工程师评价：** 还要我设计电路去处理那个讨厌的 `-0`？还要做“循环进位”来补那个丢失的 1？**麻烦，Pass！**

### 补码(two's complement)

> 想象一个挂钟。现在是 12 点。
>
> 1. 如果你想把指针拨到 11 点，你可以**逆时针**拨 1 格（做减法：12 - 1）。
> 2. 有没有办法通过**顺时针**拨动，也能指到 11 点？

- **答案：** 顺时针拨 11 格！（12 + 11 = 23，在 12 小时制的钟面上，23 就是 11）。
- **顿悟时刻：** 在有限的模数系统（Modulus）里，**减去一个数 = 加上这个数的“补数”**。
  - 减 1 = 加 11（模 12）。
  - **在这个意义上，-1 就是 11。**
- **长相：** 负数 = 反码 + 1。
  - `+7` = `0000 0111`
  - `-7` = `1111 1001`

> Q：为什么是取反加一？:happy:
>
> ### 第一步：我们的目标是什么？（数学定义）
>
> 在计算机（模数系统）里，求一个数 $X$ 的补码（也就是 $-X$），在数学上等价于：
>  **用“模”（Modulus）减去 $X$**。
>
> - 假设我们要算 4 位二进制（模是 $16$，即 `10000`）。
> - 我们要算 $-3$ 的补码。
> - **数学真理：** $\text{补码} = 16 - 3$。
>
> ------
>
> ### 第二步：遇到的困难（硬件噩梦）
>
> 我们要计算 $16 - 3$，写成二进制竖式是这样的：
> $$
> \begin{array}{r}
>   10000 \quad (\text{这是16}) \\
> - 00011 \quad (\text{这是3}) \\
> \hline
>   ?????
> \end{array}
> $$
> **发现问题了吗？**
>  你要用 `0` 减 `1`，不够减！
>  你必须从最前面的那个 `1` 开始，**连续借位 (Borrow)**，把借位像波浪一样传到最后一位。
>
> - **IC 设计师崩溃了：** 这意味着我为了算个补码，还得专门造一个复杂的“减法器”，还得处理高延迟的借位链。**说好的只用加法器（RCA）呢？**
>
> ------
>
> ### 第三步：偷天换日（数学障眼法）
>
> 工程师想：**“要是被减数全是 1 就好了，全是 1 就不需要借位了！”**
>
> 于是，他把 **$16$ (`10000`)** 拆成了 **$15 + 1$ (`1111 + 1`)**。
>
> 现在的公式变成了：
>  $16 - 3 = (15 + 1) - 3$
>
> 根据小学数学结合律，交换一下顺序：
>  $= \underbrace{(15 - 3)}_{\text{第一部分}} + \underbrace{1}_{\text{第二部分}}$
>
> ------
>
> ### 第四步：见证奇迹（为什么取反？）
>
> 我们先算第一部分：**$15 - 3$**。
>  写成二进制竖式：
> $$
> \begin{array}{r}
>   1111 \quad (\text{这是15，全是1}) \\
> - 0011 \quad (\text{这是3}) \\
> \hline
>   1100
> \end{array}
> $$
> **请盯着结果 `1100` 和原数 `0011` 看：**
>
> - 原数是 0 的位，用 1 减它，结果是 1。
> - 原数是 1 的位，用 1 减它，结果是 0。
>
> **结论：** **“用全 1 去减任何数”** $\equiv$ **“对这个数按位取反”**。
>  这也叫 **反码 (One's Complement)**。
>
> ------
>
> ### 第五步：收尾（加一）
>
> 别忘了刚才拆分时，我们还把一个 **$1$** 放在旁边没动呢。
>  现在把它加回去。
>
> $\text{最终结果} = (\text{取反后的值}) + 1$
>
> 这就是 **“取反加一”** 的由来。

### 溢出

#### 补码加法的溢出

补码也存在编码连续但真值不连续的边界

即最大数`0b0111...111`和最小数`0b1000...000`

溢出：计算结果超过编码表示范围

为了检查加法计算的结果是否符合数学意义，电路需要检测是否发生溢出

| 比较维度       | **进位 (Carry)**                      | **溢出 (Overflow)**                    |
| -------------- | ------------------------------------- | -------------------------------------- |
| **关注者**     | 无符号数 (Unsigned)                   | 有符号数 (Signed)                      |
| **含义**       | “桶装不下了”                          | “符号变错了”                           |
| **硬件信号**   | 最高位的 Carry Out                    | 最高位进位入 $\oplus$ 进位出           |
| **典型例子**   | 255 + 1 = 0 (进位了)                  | 127 + 1 = -128 (溢出了)                |
| **RISC-V指令** | `add`, `sub` (也会产生，但不一定报警) | `add`, `sub` (忽略); `addw` (可能会报) |

#### 溢出检测

跨越不连续边界分为两种情况：

1. 在正数部分往顺时针方向拨动指针, 跨越到负数部分（两个正数相加，结果为负数）
2. 在负数部分往逆时针方向拨动指针, 跨越到正数部分（两个负数相加，结果为正数）

```
              0000 (0)
      (-1) 1111  0001 (1)
   (-2) 1110   ^    0010 (2)
 (-3) 1101     |      0011 (3)
(-4) 1100      +       0100 (4)
 (-5) 1011            0101 (5)
   (-6) 1010        0110 (6)
      (-7) 1001  0111 (7)
              1000 (-8)
```

##### 方法一：符号位判别法 (双符号位逻辑)

这是最符合人类直觉的判断方法。
 **核心逻辑**：只有“正+正”或“负+负”才可能溢出。“正+负”永远不会溢出。

如果满足以下条件，就是溢出：

1. **输入同号**：$A$ 和 $B$ 的符号位相同。
2. **结果异号**：结果 $S$ 的符号位与 $A$ (或 $B$) 不同。

**逻辑表达式**：
 设 $S_A, S_B, S_S$ 分别为 A, B, Sum 的符号位 (最高位)。
 $\text{Overflow} = (S_A \cdot S_B \cdot \overline{S_S}) + (\overline{S_A} \cdot \overline{S_B} \cdot S_S)$

- 第一项：两个负数相加，变成了正数 (下溢)。
- 第二项：两个正数相加，变成了负数 (上溢)。

------

##### 方法二：进位异或法 (单符号位逻辑) —— **工程最常用**

这是在硬件电路设计（包括 CPU ALU 设计）中**最简单、最常用**的方法，因为它不需要去检查整个结果，只需要看**最后两个进位信号**。

**核心逻辑**：
 观察最高位（符号位）全加器的两个进位信号：

1. **$C_{in\_MSB}$**：**进入**最高位的进位（即次高位向最高位的进位）。
2. **$C_{out\_MSB}$**：**走出**最高位的进位（即最高位向更高位的进位）。

**判定公式**：
 $\text{Overflow} = C_{in\_MSB} \oplus C_{out\_MSB}$
 *(即：如果这两个进位信号不一样，就是溢出)*

**原理分析**：

- **正 + 正 (0 + 0)**：如果次高位进位了 ($C_{in}=1$)，导致符号位变成 1，但符号位没向外进位 ($C_{out}=0$)。$\to 1 \oplus 0 = 1$ (**上溢**)
- **负 + 负 (1 + 1)**：符号位本身产生 $C_{out}=1$。如果次高位没进位 ($C_{in}=0$)，结果符号位会变成 0。$\to 0 \oplus 1 = 1$ (**下溢**)
- **正 + 负**：这种情况 $C_{in}$ 和 $C_{out}$ 永远是一样的，异或结果为 0，**永不溢出**。





## 时序逻辑电路

组合逻辑电路的输出完全由当前输入决定

新需求：如何实现电子表中`新的秒数=旧的秒数+1`?

通过时序逻辑电路实现可以存储状态的电路

### 交叉配对反相器(Cross-Coupled Inverters)

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/8cd44ebb6a2ad1735c95940a8b47b48d870c8073.png)

#### 1. 核心结构（长什么样？）

- 由 **两个反相器 (NOT Gate)** 组成。
- **连接方式**：首尾相连（第一个的输出接第二个的输入，第二个的输出接第一个的输入）。

#### 2. 核心功能（干什么用？）

- 它是数字电路中 **“记忆”** 的最小单元。
- 学术名称：**双稳态电路 (Bistable Circuit)**。
- 能力：可以存储 **1 bit** 的数据（存0或存1）。

#### 3. 运行逻辑（怎么理解？）

- **关键词：正反馈 (Positive Feedback) / 自锁 (Self-locking)**。
- **逻辑推演**：
  - 假设输入是 1 $\to$ 经过第一级变成 0 $\to$ 经过第二级变回 1。
  - **结论**：输出 = 输入 ($Q = Q$)。信号自己“咬住”了自己，不需要外界维持也能保持状态。

#### 4. 三种状态（考点）

- ✅ **稳态 1**：$Q=1, \bar{Q}=0$（稳定，锁住信息 "1"）。
- ✅ **稳态 2**：$Q=0, \bar{Q}=1$（稳定，锁住信息 "0"）。
- ❌ **亚稳态/非稳态**：$Q$ 和 $\bar{Q}$ 同时为 0 或同时为 1。
  - **特点**：逻辑上矛盾，实际上极不稳定。现实电路中会因为微小的干扰瞬间“坍缩”回上面两种稳态之一。

### SR锁存器

Set（置位） Reset（复位）锁存器，其中S和R用于控制锁存器的状态

**R (Reset)** 端：连接在 **Q** 输出的那一侧。

- (给 1 就把 Q 变成 0)

**S (Set)** 端：连接在 **$\bar{Q}$** 输出的那一侧。

- (给 1 就把 $\bar{Q}$ 变成 0 $\to$ 逼迫 Q 变成 1)

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/aa8cfb24fd05163cd8be1d352bf2f44b1acb6043.png)

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/b0d1fb74bdfab99e7f8fdd0232ba5effd0e300ec.png)

1. 当`S=1, R=0`时, 上方或非门的行为和反相器一致, 下方或非门的输出恒为`0`. 此时`Q`为`1`, 故将SR锁存器存储的值更新为`1`.
2. 当`S=0, R=1`时, 上方或非门的输出恒为`0`, 下方或非门的行为和反相器一致. 此时`Q`为`0`, 故将SR锁存器存储的值更新为`0`.
3. 当`S=0, R=0`时, 两个或非门的行为和反相器一致. 此时SR锁存器的行为与交叉配对反相器一致, 故SR锁存器将保持之前存储的值.
4. 当`S=1, R=1`时, 两个或非门的输出恒为`0`, 此时无法表示有效的信息. 同时, 输入从`S=1, R=1`变为`S=0, R=0`时, 相当于让交叉配对反相器进入的状态. 根据上文的分析, 这将导致SR锁存器进入亚稳态, 因此需要避免.

| `S`  | `R`  |      | `Q`  |
| :--: | :--: | :--: | :--: |
|  0   |  0   |      | 保持 |
|  0   |  1   |      |  0   |
|  1   |  0   |      |  1   |
|  1   |  1   |      | 禁止 |

### D锁存器

避免亚稳态

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0005c05d8b79336f931ac02bb927b87c82833c26.png)

D为输入数据

WE为写使能(Write Enable)

- 写使能有效时，将D的当前值写入锁存器

- 写使能无效时，锁存器保持不变

|  WE  |  D   |      |  S   |  R   |      |  Q   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |      |  0   |  0   |      | 保持 |
|  0   |  1   |      |  0   |  0   |      | 保持 |
|  1   |  0   |      |  0   |  1   |      |  0   |
|  1   |  1   |      |  1   |  0   |      |  1   |

#### 用与非门搭建的D锁存器

<img src="https://gitee.com/helloworld-dlx/typora/raw/master/20260127162807857.png" alt="image-20260127162758635" style="zoom:50%;" />

面积更小

### 同步电路

同步 = **步调一致**（按照同一个节奏做不同的事）

所有元件的状态变化都**对齐**在同一个**时间基准（时钟信号的边沿）**上

#### 复杂系统中的同步关系

一个复杂系统包含多个模块，需要考虑如何控制多个模块协同工作

需要正确实现一种同步关系：事件A在事件B之后发生

#### 同步电路=通过全局的时钟信号实现同步关系

 时钟信号是如下图所示的脉冲信号, 它在高低电平之间来回翻转, **一次高电平和一次低电平加起来称为一个周期**

```
时钟信号示例
            +--- positive edge          +--- negative edge
            V                           V
    +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
+---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +
```

- 从低电平翻转为高电平，称为正边沿(positive edge)或者上升沿
- 从高电平翻转为低电平，称为负边沿(negative edge)或者下降沿

同步电路的设计=把需要同步的事件划分到不同的周期中，由时钟信号控制这些事件的先后顺序

#### 异步电路

通过模块之间的局部通信信号实现同步关系

同步电路设计简单，电路分析简单，但功耗较高

异步电路无时钟开销，功耗低

#### 仅靠D锁存器无法实现同步电路的特性

WE有效时，输入的变化马上传播到输出

锁存器属于电平触发(level-triggered)的存储元件, 只要输入发生变化, 锁存器就能立即感知, 并将该变化传播到输出端.

相比之下, 我们需要一种边沿触发(edge-triggered)的存储元件, 只有信号边沿到来时, 才将输入传播到输出端

### D触发器(D Flip-Flop,DFF)

一种边沿触发的存储元件

左下方的>表示需要连接时钟信号

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/6bcf7eb766ced95806c75490f70ba9dc060ac43e.png)

主从式D触发器：由两个D锁存器构成，左边为主锁存器，右边为从锁存器

<img src="https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/9ab76d4a01bbe8d6031ccd52a10667193d756e31.png" alt="image" style="zoom:67%;" />

#### D触发器的工作过程

1. 数据准备阶段. 

   此时时钟信号`clk`处于低电平, 故主锁存器的写使能端有效, 数据信号`D`可从外部进入主锁存器; 

   但由于从锁存器的写使能端无效, 故数据信号无法传播到从锁存器, 因而整个D触发器的输出端`Q`保持不变.

2. 采样阶段. 

   当时钟信号`clk`的上升沿到来时, 主锁存器的写使能端无效, 数据信号`D`无法从外部进入主锁存器, `D`的后续变化将无法对主锁存器造成影响, 从而将时钟信号上升沿到来前的外部数据`D`"锁"在主锁存器中. 

   与此同时, 从锁存器的写使能端开始有效, 主锁存器中"锁住"的数据将传播到从锁存器, 并作为整个D触发器的输出.

3. 维持阶段. 

   此时时钟信号`clk`处于高电平, 故主锁存器的写使能端无效, 因此不受数据信号`D`变化的影响; 

   从锁存器的写使能端虽然有效, 但由于主锁存器保持不变, 故从锁存器也保持不变, 因而整个D触发器的输出端`Q`保持不变.

当时钟上升沿到来时, 数据被写入D触发器

D**触发器是同步电路设计中的基本存储元件**

#### 带复位端的D触发器

<img src="https://gitee.com/helloworld-dlx/typora/raw/master/20260128110016901.png" alt="image-20260128110007410" style="zoom:50%;" />

`resetn`为低电平有效的复位信号

当`resetn`为1时，其功能与之前D触发器相同

当`resetn`为0时，将往D触发器写入0

即使`resetn`为0，也需要等待上升沿到来时执行清零操作（同步复位）

#### 下降沿的D触发器

**原版 (上升沿)**：

- Master 接收 $\overline{CLK}$ (低电平通)。
- Slave 接收 $CLK$ (高电平通)。

**修改版 (下降沿)**：

- **Master** 改为接收 **$CLK$** (高电平通)。
  - *(这样 CLK=1 时，Master 就在采样)*
- **Slave** 改为接收 **$\overline{CLK}$** (低电平通)。
  - *(这样 CLK 变成 0 时，Slave 才开门放行)*

#### 带使能端的D触发器

<img src="https://gitee.com/helloworld-dlx/typora/raw/master/20260128151714985.png" alt="image-20260128151713191" style="zoom:50%;" />

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/bbe2ddba030a3351a55f56eab35b81425e3a2db0.png)

- EN有效时，选择D作为D触发器的输入
- EN无效时，选择D触发器中存储的当前数据作为D触发器的输入（即D触发器中存储的值保持不变）

### 寄存器(register)

可同时读写多位的结构

由多个D触发器组成

可采用带置位端或者复位端的D触发器，实现寄存器的初始化

如依次采用DFFS,DFFR,DFFR,DFFS来构成4位寄存器，使其在电路复位后存储9（`0b1001`)

